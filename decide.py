#                                                                                   $$$$$$
#	  %%%%%   %%%%%    #######                                                 $$()$$$$
#	 %%%%%%% %%%%%%%   ###  ###                ##                                 $$$$$;;
#	%%%%%%%%%%%%%%%%%  ###  ###           ##   ##                           $$$$$$$$$$;;;;;
#	 %%%%%%%%%%%%%%%   ######   ##   ##  ####  ######    ####   #####      $$$$$$$$$;;;;;;;;
#	   %%%%%%%%%%%     ##        ## ##    ##   ##   ##  ##  ##  ##   ##     $$$;;;;;;;;;;;;
#	      %%%%%        ##         ##      ##   ##   ##  ##  ##  ##   ##      $$;;;;;
#	        %          ##        ##        ##  ##   ##   ####   ##   ##         ;;;;;();;
#										     ;;;;;;
#Для мотивации, радости и желании работать


# Это будущий объект для хранения информации о части с которой работает интерпретатор на данный момент
prior = {
	'en_index': None,
	'st_index': None,
	'op_index': None,
	'example': None,
	'operator': None
}
# Это будущий объект содержащий информацию о первоначальном состоянии примера
proto = {}
# По идей тут должен быть инпут, строка присвоена чтоб не парится
input_ex = '2+2*2'

def analize():
	# выставляем все переменные как глобальные
	global prior
	global proto
	global input_ex
	# будущая функция для нахождения индекса приоритетного оператора
	def get_index(operator):
		# Так нужно
		pass
	# фунция для нахождения пассивного числа (числителя)
	def get_passive():
		# Содержит в себе пассивное число и будет ретарнино по окончании интерпретации
		string = 0
		# интерпретатор
		for sym in input_ex[:prior['op_index']:-1]: # перебираем символы в подстроке
			# блок-try (трай) служит для ловли ошибок 
			print(sym)
			try:
				# Если содержимое трай вызывает ошибку... ->
				# пробуем, я посставил это в начало чтобы переменной пассивного числа не присваивалась всякаяя фигня
				int(sym)
				# теперь присваеваем
				string+=sym
			except TypeError:
				# <- ...то выполнится блок-ексепт
				# ретарн пассивного числа
				return string
	# всё тоже самое только для активного числа (знаменателя)
	def get_active():
		string = 0
		for sym in input_ex[prior['op_index']::+1]:
			try:
				int(sym)
				string+=int(sym)
			except TypeError:
				return string

	# Вот тут начинается объектная жесть
	for i in input_ex:
		# делить добавим потом, для начала нужен алгоритм
		if(i=='*'):
			# присваиваем объекту все свойства
			prior = {
				# Это нужно на будущее
				'en_index': None,
				'st_index': None,
				# индекс оператора
				'op_index': "1", #get_index('*'),
				# подстрока с приоритетной частью примера
				'example': input_ex[get_passive():get_active():],
				# Да, это тоже важно
				'operator': '*'
			}

			proto = {
				# Это всё тоже на будущее
				'example': input_ex,
				'index': 0
			}
# Всё будет оформлено в виде модуля, так что обернуть функцию и вызвать её - это обязательно
analize()
