# А сейчас я поведаю об алгоритме сией программы
# есть функция analize, в которой сначала объявляются функции get_passive & get_active а потом гоняем по всему примеру циклом и всю инфу заносим в объекты
# цикл в конце анализирует два объекта: prior и proto, prior - объект выражения приоритетного оператора таких как умножить и делить, proto это инфа обо всём выражении в целом
# get_active - функция добывающая активное число, т. е. число НА которое делят, вычитают, суммируют...
# get_passive - добывает пассивное число, 3+2 пассивное 3, активное 2
# сейчас всё работает фигово... но синтаксические ошибки исправлены, интерпретатор не ругается
# 
# 
# 
# 
# 
# поля на будущее...
# 
# 
# 
# 
# 
# объект PRIOR
данная вещь собирает данные о пассивном и активном числе более приоритетного оператора. У нас есть операция: 2+2*2
здесь есть, более приоритетное чем сумма, произведение и когда через цикл находится это умножение приор собирает все данные об этом активное:2 пассивное:2 индекс 
оператора: 3и т.п.
# фунция GET_PASSIVE
Эта хр*нь над которой я парился больше всего, через цикл она гоняет начиная от числа равному индексу оператора в примере и пока преобразование символа в строку не
вызывает ошибку она не прекратит идти к началу (поэтому переменные наш калькулятор решать никогда не сможет гыыы ^______^). Плюс по окончанию работы информирует 
индекс начала операции, это нужно чтобы потом вырезать все числа и знаки связанные с этой операцией, а потом вставлять на их место результат вычислений. Там ёще есть 
условие одно, оно нужно на случай если операция начинается в самом начале примера. Кст в функции get_active() всё тоже самое, только цикл идёт от оператора к концу 
строки и информирует о конце операции в примере
# функция DECIDE
Там всё понятно, берём числа с объекта и производим нужные операции
# Циклы в конце
Они ищат приоритет среди остальных операций и начинают присваивание приору всё самое необходимое
Пару слов об инвалидском присваивании приору информации
Так было нужно потому что почему-то при нормальном присваивании приору свойств они внезапно становятся кортежами 0__0
Я не знаю почему так происходит, в гугле ничего не нашёл, поэтому пришлось искать рабочие альтернативы
